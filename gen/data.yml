---
CANDigitalInput:
  methods:
    CANDigitalInput:  # constructor
      code: |
        self._device = device
        self._limitSwitch = limitSwitch
        polarity_param = (
            "limitSwitchFwdPolarity"
            if limitSwitch is LimitSwitch.kForward
            else "limitSwitchRevPolarity"
        )
        device._hal_data[polarity_param] = polarity
    Get:
      code: |
        retval = self._device.getFault(
            FaultID.kHardLimitFwd
            if self._limitSwitch is LimitSwitch.kForward
            else FaultID.kHardLimitRev
        )
    EnableLimitSwitch:
      code: |
        param = (
            "hardLimitFwdEn"
            if self._limitSwitch is LimitSwitch.kForward
            else "hardLimitRevEn"
        )
        self._device._hal_data[param] = enable
    IsLimitSwitchEnabled:
      code: |
        param = (
            "hardLimitFwdEn"
            if self._limitSwitch is LimitSwitch.kForward
            else "hardLimitRevEn"
        )
        retval = self._device._hal_data[param]

CANEncoder:
  methods:
    CANEncoder:  # constructor
      code: |
        self._device = device
        self._hal_data = device._hal_data
    GetPosition:
      get: position
    GetVelocity:
      get: velocity

CANPIDController:
  methods:
    CANPIDController:  # constructor
      code: |
        self._device = device
        self._hal_data = device._hal_data
    SetReference:
      code: |
        if self._device._inverted:
            value = -value
            arbFeedforward = -arbFeedforward
        self._hal_data["value"] = float(value)  # TODO
        self._hal_data["ctrlType"] = ctrl
        self._hal_data["pid_slot"] = pidSlot
        self._hal_data["arb_ff"] = arbFeedforward
    SetP:
      hook: pid_set
    SetI:
      hook: pid_set
    SetD:
      hook: pid_set
    SetFF:
      hook: pid_set
    SetIZone:
      hook: pid_set
    SetOutputRange:
      code: |
        self._hal_data["outputMin_%d" % slotID] = float(min)
        self._hal_data["outputMax_%d" % slotID] = float(max)
    GetP:
      hook: pid_get
    GetI:
      hook: pid_get
    GetD:
      hook: pid_get
    GetFF:
      hook: pid_get
    GetIZone:
      hook: pid_get
    GetOutputMin:
      hook: pid_get
    GetOutputMax:
      hook: pid_get

CANSparkMaxLowLevel:
  methods:
    CANSparkMaxLowLevel:  # constructor
      skip_pybind: true
      code: |
        raise TypeError("Cannot instantiate CANSparkMaxLowLevel")
    GetFirmwareVersion:
      ignore: true  # overload + out param
    GetSerialNumber:
      code: |
        retval = []
    GetDeviceId:
      code: |
        retval = self._deviceID
    SetMotorType:
      set: motorType
    GetMotorType:
      get: motorType
    SetPeriodicFramePeriod:
      code: |
        self._hal_data["frame_period"][frame] = periodMs
    SetControlFramePeriod:
      set: control_period_ms
    GetControlFramePeriod:
      get: control_period_ms
    # TODO GetParameterType
    SetParameter:
      overload: true
    GetParameter:
      ignore: true  # overload + out param

  sim_class_extra: |
    def setParameter(
        self,
        parameterID: ConfigParameter,
        value: typing.Union[float, int]
    ) -> ParameterStatus:
        """
        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.
        """
        assert isinstance(parameterID, ConfigParameter)
        assert isinstance(value, (float, int))
        raise NotImplementedError("setParameter not implemented in simulation (file a bug on github if you need it)")

CANSparkMax:
  __bases__: CANSparkMaxLowLevel
  cpp_inherits: rev::CANSparkMaxLowLevel

  methods:
    CANSparkMax:  # constructor
      param_override:
        type:
          x_type: rev::CANSparkMaxLowLevel::MotorType
      code: |
        # everything that would be in the low-level constructor
        # do not call super().__init__()
        self._deviceID = deviceID
        self._inverted = False
        self._faults = NotifyDict({})  # type: typing.Dict[FaultID, bool]
        # camel case for stored parameters (see CANSparkMaxLowLevel::ConfigParameter)
        self._hal_data = NotifyDict({
            "can_timeout": 20,
            "value": 0.0,
            "position": 0.0,
            "velocity": 0.0,
            "ctrlType": ControlType.kDutyCycle,
            "pid_slot": 0,
            "arb_ff": 0.0,
            "faults": self._faults,
            "limitSwitchFwdPolarity": LimitSwitchPolarity.kNormallyOpen,
            "limitSwitchRevPolarity": LimitSwitchPolarity.kNormallyOpen,
            "hardLimitFwdEn": False,
            "hardLimitRevEn": False,
            "smartCurrentStallLimit": 40,  # TODO
            "smartCurrentFreeLimit": 0,  # TODO
            "smartCurrentConfig": 20000,
            "currentChop": 60.0,  # TODO
            "currentChopCycles": 0,
            "idleMode": IdleMode.kCoast,
            "rampRate": 0.0,
            "bus_voltage": 12.0,
            "output_current": 0.1,
            "motor_temp": 25.0,  # ~room temperature
            "frame_period": NotifyDict({
                PeriodicFrame.kStatus0: 10,
                PeriodicFrame.kStatus1: 20,
                PeriodicFrame.kStatus2: 50,
            }),
            "control_period_ms": 10,
        })
        for i in range(4):
            self._hal_data.update({
                "p_%d" % i: 0.0,
                "i_%d" % i: 0.0,
                "d_%d" % i: 0.0,
                "f_%d" % i: 0.0,
                "iZone_%d" % i: 0.0,
                "outputMin_%d" % i: 0.0,
                "outputMax_%d" % i: 0.0,
            })
        self.setMotorType(type)
        hal_data["CAN"]["sparkmax-%d" % deviceID] = self._hal_data
        hal.report(hal.UsageReporting.kResourceType_RevSparkMaxCAN, deviceID)

        self.clearFaults()

    Set:
      code: |
        if self._inverted:
            speed = -speed
        self._hal_data["value"] = float(speed)
        self._hal_data["ctrlType"] = ControlType.kDutyCycle
        self._hal_data["pid_slot"] = 0
        self._hal_data["arb_ff"] = 0.0
    Get:
      get: value  # close enough
    SetInverted:
      code: |
        self._inverted = isInverted
    GetInverted:
      code: |
        retval = self._inverted
    Disable:
      code: |
        self.set(0)
    StopMotor:
      code: |
        self.disable()
    PIDWrite:
      rename: pidWrite
      code: |
        self.set(output)
    GetEncoder:
      code: |
        retval = CANEncoder(self)
    GetPIDController:
      code: |
        retval = CANPIDController(self)
    GetForwardLimitSwitch:
      code: |
        retval = CANDigitalInput(self, LimitSwitch.kForward, polarity)
    GetReverseLimitSwitch:
      code: |
        retval = CANDigitalInput(self, LimitSwitch.kReverse, polarity)
    SetSmartCurrentLimit:
      overload: true
    SetSecondaryCurrentLimit:
      code: |
        self._hal_data["currentChop"] = float(limit)
        self._hal_data["currentChopCycles"] = limitCycles
      doc: |
        Sets the secondary current limit in Amps.

        The motor controller will disable the output of the controller briefly
        if the current limit is exceeded to reduce the current. This limit is
        a simplified 'on/off' controller. This limit is enabled by default
        but is set higher than the default Smart Current Limit.

        The time the controller is off after the current limit is reached
        is determined by the parameter limitCycles, which is the number of
        PWM cycles (20kHz). The recommended value is the default of 0 which
        is the minimum time and is part of a PWM cycle from when the over
        current is detected. This allows the controller to regulate the current
        close to the limit value.

        The total time is set by the equation::

          t = (50us - t0) + 50us * limitCycles
          t = total off time after over current
          t0 = time from the start of the PWM cycle until over current is detected

        :param limit: The current limit in Amps.
        :param limitCycles: The number of additional PWM cycles to turn
                            the driver off after overcurrent is detected.
    SetIdleMode:
      set: idleMode
    GetIdleMode:
      get: idleMode
    SetRampRate:
      code: |
        if rate != 0.0:
            rate = 1 / rate
        else:
            rate = 0.0
        self._hal_data["rampRate"] = rate
    GetRampRate:
      code: |
        retval = self._hal_data["rampRate"]
        if retval != 0.0:
          retval = 1 / retval
    Follow:
      ignore: true  # overload + struct
    # TODO IsFollower
    GetFaults:
      code: |
        retval = 0
        for faultID, value in self._faults.items():
            retval |= value << faultID.value
    GetStickyFaults:
      code: |
        retval = 0
    GetFault:
      code: |
        retval = self._faults.get(faultID, False)
    GetStickyFault:
      code: |
        retval = False
    GetBusVoltage:
      get: bus_voltage
    GetAppliedOutput:
      get: value
    GetOutputCurrent:
      get: output_current
    GetMotorTemperature:
      get: motor_temp
    ClearFaults:
      code: |
        faults = self._hal_data["faults"]
        faults.clear()
        faults.update({
            FaultID.kHardLimitFwd: False,
            FaultID.kHardLimitRev: False,
        })
    BurnFlash:
      code: ""
    SetCANTimeout:
      set: can_timeout
